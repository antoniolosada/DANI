#include <Arduino.h>
#include "pines.h"
#include <RF24.h>
#include <RF24_config.h>
#include <VirtualWire.h>
#include "list.h"
#include "node_cpp.h"
#ifndef CODE_LIST
	#include "list.cpp"
	#include "node_cpp.cpp"
#endif
#include "SAPPO.h"

/* SAPPO Configuración *********************************************************************************/
#define MAX_EMISORES_ULTRASONIDOS   12
#define MAX_BALIZAS					2
#define EMISION_CONJUNTA			-1

RF24 radio(PIN_NRF24_CE, PIN_NRF24_CSN);
const uint64_t pipe1 = 0x00000000E1LL;    // Usamos este canal
const uint64_t pipe2 = 0x00000000E2LL;    // Usamos este canal
const uint64_t broadcast = 0xE8E8F0F0E1LL; // Usamos este canal
char direccion[3][6] = {"0Nodo", "1Nodo", "2Nodo"};

List<sBaliza> ListaBalizas;
List<sMedidas> ListaMedidasBalizas;
sProcesoMedida ProcesoMedida;
byte aTrigger[MAX_EMISORES_ULTRASONIDOS] =
						{PIN_TRIGGER_SAPPO_DER_1, PIN_TRIGGER_SAPPO_DER_2, PIN_TRIGGER_SAPPO_DER_3,
						 PIN_TRIGGER_SAPPO_DER_4, PIN_TRIGGER_SAPPO_DER_5, PIN_TRIGGER_SAPPO_DER_6,
						 PIN_TRIGGER_SAPPO_IZQ_1, PIN_TRIGGER_SAPPO_IZQ_2, PIN_TRIGGER_SAPPO_IZQ_3,
						 PIN_TRIGGER_SAPPO_IZQ_4, PIN_TRIGGER_SAPPO_IZQ_5, PIN_TRIGGER_SAPPO_IZQ_6};
sPaquete paquete[MAX_BALIZAS];

int SensorEmisor = EMISION_CONJUNTA;
/* SAPPO Configuración **********************************************************************************/



bool RecuperarMedidasBalizas(int algoritmo, bool salida)
{
  float minimo, medida[2], media, maximo;
  int medidas, id_baliza_x = 0, id_baliza_y = 0;
  boolean timeout;
  int baliza1, baliza2;

  minimo = 999;
  maximo = 0;
  media = 0;
  medidas = 0;

  // Recuperamos dos medidas de sensores contrapuestos v?lidos para
  // triangulaci?n
  //timeout = RecuperarMedidaMultiple(SensorEmisor, LOG_MEDIDAS | LOG_LECTURAS);
  timeout = RecuperarMedidaMultiple(SensorEmisor, false);

  // Si timeout = true implica que no hemos podido recuperar dos medidas v?lidas
  // para triangular
  if (!timeout)
  {
    // Primero comprobamos que los identificadores de las balizas son correctas
    if ((paquete[0].id_baliza != paquete[1].id_baliza) && (paquete[1].id_baliza+paquete[1].id_baliza != 0))
    {
        baliza1 = (paquete[0].id_baliza == 1)?0:1;
        baliza2 = (baliza1 == 0)?1:0;

      // Convertimos el tiempo a cm
        medida[0] = Tiempo2Distancia(paquete[baliza1].tiempo);
        medida[1] = Tiempo2Distancia(paquete[baliza2].tiempo);

        sensor_baliza[0] = paquete[baliza1].num_sensor;
        sensor_baliza[1] = paquete[baliza2].num_sensor;

      //Salida EXCEL
	  //plot(paquete[0].tiempo/10, paquete[1].tiempo/10); Serial.println("");

      // Verificamos si las dos medidas son correctas
      if (((medida[0] > 10) && (medida[0] < 1000)) &&
          ((medida[1] > 10) && (medida[1] < 1000)))
      {
    	  MedidaX = medida[0];
    	  MedidaY = medida[1];

    	  if (filtro & KALMAN1)
    	  {
			  filtroX = myFilterX.getFilteredValue(medida[0]);
			  filtroY = myFilterY.getFilteredValue(medida[1]);
			  if (salida)
			  {
				Serial.print(filtroX);
				Serial.print(",");
				Serial.print(filtroY);
			  }
    	  }
    	  if (filtro & MEDIA)
    	  {
			  filtroX_media = filtroMediaX.AddValue(medida[0]);
			  filtroY_media = filtroMediaY.AddValue(medida[1]);
			  if (salida)
			  {
				Serial.print(filtroX_media);
				Serial.print(",");
				Serial.print(filtroY_media);
			  }
    	  }
    	  if (filtro & MEDIA_EVOLUTIVA)
    	  {
    		  if (MediaX == 0)
    			  MediaX = medida[0];
    		  else
    			  MediaX = (MediaX+MedidaX) /2;
    		  if (MediaY == 0)
    			  MediaY = medida[1];
			  else
				  MediaY = (MediaY+MedidaY) /2;

			  if (salida)
			  {
				Serial.print(MediaX);
				Serial.print(",");
				Serial.print(MediaY);
			  }
    	  }
    	  if (salida == SALIDA_COMPLETA)
    		  LOG_DEBUG("MED:",paquete[0].id_baliza, paquete[1].id_baliza, paquete[0].tiempo, paquete[1].tiempo);
  		return true;
      } //if medida
    } //if paquete
  } //if timeout
  return false;
}

boolean RecuperarMedidaMultiple(int emisor, int LOG) {
  paquete[0].id_baliza = 0;
  paquete[1].id_baliza = 0;
  // radio.write(&paquete, sizeof(paquete));
  EnviarMensaje433Mhz(0);
  EnviarPulsoUltrasonidos(emisor);

  radio.startListening();

  unsigned long started_waiting_at = millis();
  bool timeout = false;

  float medida;
  int numero_medidas = 0;
  while (!timeout && (numero_medidas < NUM_BALIZAS_RECUPERAR)) // Esperamos
  {
    while ((!radio.available()) && !timeout) // Esperamos
    {
    	if (!PararMotores) SoftwareServo::refresh();

    	if (millis() - started_waiting_at > TIMEOUT_MEDIDA_US) {
    		timeout = true;
    		//Serial.println("err");
      }
    }

    if (!timeout) { // Leemos el mensaje recibido
      unsigned long got_time;
      radio.read(&paquete[numero_medidas], sizeof(sPaquete));
      radio.flush_rx();
      // medida = 1.0 * paquete[numero_medidas].tiempo / 29.2;   //convertimos a
      // distancia, en cm paquete[numero_medidas].tiempo = medida;

      if (LOG & LOG_MEDIDAS)
      {
    	  if (paquete[numero_medidas].id_baliza == 2)
    	  {
              Serial.print("medida ");
              Serial.print(paquete[numero_medidas].id_baliza);
              Serial.print(",");
              Serial.print(paquete[numero_medidas].num_sensor);
              Serial.print(",");
              Serial.println(cont_loop);
    	  }
      }
      numero_medidas++;
    }
  }

  if (!timeout)
  {
    int baliza2, baliza1;
    if (paquete[0].id_baliza == 1)
    {
        baliza1 = 0;
        baliza2 = 1;
    }
    else
    {
        baliza1 = 1;
        baliza2 = 0;
    }
    if (LOG & LOG_LECTURAS)
    {
      Serial1.print("lectura: ");
      Serial1.print(paquete[baliza2].tiempo);
      Serial1.print(" - ");
      Serial1.print(paquete[baliza2].id_baliza);
      Serial1.print(" , ");
      Serial1.print(paquete[baliza1].tiempo);
      Serial1.print(" - ");
      Serial1.println(paquete[baliza1].id_baliza);
    }
}

  radio.stopListening();

  return timeout;
}
void InicializarRadio()
{
	  // Inicializar RF 433MHz
	  vw_set_tx_pin(PIN_RF);
	  vw_setup(2500); // Bits per sec
	  // vw_rx_start();       // Start the receiver PLL running

	  //Inicializar nRF24L01
	  radio.begin();
	  //radio.setPALevel(RF24_PA_HIGH);
	  //radio.openReadingPipe(0, broadcast);
	  radio.openReadingPipe(1, pipe1);
	  radio.openReadingPipe(2, pipe2);

	  radio.setChannel(108);
	  radio.setRetries(3, 3);
	  radio.setAutoAck(true);
}

void InicializarSAPPO_us()
{
	  for (int i = 0; i < MAX_EMISORES_ULTRASONIDOS; i++) {
	    pinMode(aTrigger[i], OUTPUT);
	  }}

void CargarDatosBalizas() {
  sBaliza Baliza;
  Baliza.codigo = 1;
  Baliza.id_baliza = 1;
  Baliza.id_habitacion = 1;
  Baliza.grados_cobertura = 90;
  Baliza.direccion = 1;
  Baliza.numero_sensores = 4;
  Baliza.X = 10;
  Baliza.Y = 10;
  Baliza.Z = 10; // Altura de los sensores desde el suelo
  ListaBalizas.add_head(Baliza);

  Baliza.codigo = 2;
  Baliza.id_baliza = 2;
  Baliza.id_habitacion = 1;
  Baliza.grados_cobertura = 90;
  Baliza.direccion = 1;
  Baliza.numero_sensores = 4;
  Baliza.X = 210;
  Baliza.Y = 10;
  Baliza.Z = 10;
  ListaBalizas.add_head(Baliza);
}


